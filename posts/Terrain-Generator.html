<!DOCTYPE HTML>
<!--
	Landed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Jack Madden - Template</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="/assets/css/main.css" />
		<noscript><link rel="stylesheet" href="/assets/css/noscript.css" /></noscript>
		<style>
		p {
  			margin-left: auto;
  			margin-right: auto;
  			width: 75%;
		}
		img {
 			display: block;
  			margin-left: auto;
  			margin-right: auto;
		}
		</style>

	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<div id="header-template"><!--Your header.html placeholder--></div>

			<!-- Main -->
				<div id="main" class="wrapper style1">
					<div class="container">
						<header class="major">
							<h2>Template</h2>
							<!--<p></p>-->
						</header>

						<!-- Content -->
							<section id="content">
									<p></p>
									
									<pre>
										<code>
arraymapmaker[order_, initialjitter1_, initialjitter2_, jitterfunction1_, jitterfunction2_, read_, filename_] := 
 
 Module[{size, base, mid, map, new, dimlist, squarecorners, diamondcorners, dim, file, jitter1, jitter2, initialjitter, cornerx, cornery},
  
  size = 2^order + 1;
  initialjitter := RandomReal[{initialjitter1, initialjitter2}];
  map = SparseArray[{{1, 1} -> initialjitter, {size, size - 1} -> 0, {1, size - 1} -> 0, {size, 1} -> initialjitter}];
  mid[n_] := (n + 1)/2;
  dimlist = Reverse[Table[2^i + 1, {i, 1, order}]];
  file = filename;
  
  Do[
   dim = dimlist[[i]];
   squarecorners = 
    Flatten[Table[{y (dim - 1) + 1, x (dim - 1) + 1}, 
    {y, 0, (size - 1)/(dim - 1) - 1, 1}, 
    {x, 0, (size - 1)/(dim - 1) - 1, 1}], 1];
   diamondcorners = 
    DeleteDuplicates[
     Join[Flatten[
       Table[{y (dim - 1) + 1, Mod[x (dim - 1) + 1, size - 1, 1]}, {y, 0, (size - 1)/(dim - 1), 1}, {x, 0, (size - 1)/(dim - 1), 1}], 1], 
      Flatten[Table[{y (dim - 1) + 1 - 1 + mid[dim], x (dim - 1) + 1 - 1 + mid[dim]}, 
	 {y, 0, (size - 1)/(dim - 1) - 1, 1}, 
	 {x, 0, (size - 1)/(dim - 1) - 1, 1}], 1]]];
   jitter1 = jitterfunction1;
   jitter2 = jitterfunction2;
   
   Do[
    cornery = squarecorners[[i, 1]];
    cornerx = squarecorners[[i, 2]];
    new = (map[[cornery, cornerx]] + 
         map[[cornery, Mod[cornerx - 1 + dim, size - 1, 1]]] + 
         map[[cornery - 1 + dim, cornerx]] + 
         map[[cornery - 1 + dim, 
          Mod[cornerx - 1 + dim, size - 1, 1]]])/4. + 
      RandomReal[{jitter1, jitter2}];
    (map[[cornery - 1 + mid[dim], cornerx - 1 + mid[dim]]] = #) &@new;
    
    , {i, 1, Length[squarecorners]}];
    
   If[read == 1, Export[file, map, "HarwellBoeing"]];
   Print["Completed Squares for dimension  " <> ToString[dimlist[[i]]]]
    
    Do[
     cornery = diamondcorners[[i, 1]];
     cornerx = diamondcorners[[i, 2]];
     
     If[(cornery - 1 + mid[dim]) > size,(*southpole*)
      new =
       (map[[cornery, cornerx]]
          + map[[cornery, Mod[cornerx - 1 + dim, size - 1, 1]]]
         (*+map[[cornery+1-mid[dim],Mod[cornerx-1+mid[dim],size-1,1]]]*))/2.(*+RandomReal[{jitter1,jitter2}]*),
      
      If[cornery + 1 - mid[dim] <= 0,(*northpole*)
       new =
        (map[[cornery, cornerx]]
           + map[[cornery, Mod[cornerx - 1 + dim, size - 1, 1]]]
          (*+map[[cornery-1+mid[dim],Mod[cornerx-1+mid[dim],size-1,1]]]*))/2.(*+RandomReal[{jitter1,jitter2}]*),
       
       new =
        (map[[cornery, cornerx]]
            + map[[cornery, Mod[cornerx - 1 + dim, size - 1, 1]]]
            + 
            map[[cornery - 1 + mid[dim], 
             Mod[cornerx - 1 + mid[dim], size - 1, 1]]]
            + 
            map[[cornery + 1 - mid[dim], 
             Mod[cornerx - 1 + mid[dim], size - 1, 1]]])/4. + RandomReal[{jitter1, jitter2}]]];
     (map[[cornery, Mod[cornerx - 1 + mid[dim], size - 1, 1]]] = #) &@new;
     ,
     {i, 1, Length[diamondcorners]}];
   If[read == 1, Export[file, map, "HarwellBoeing"]];
   Print["Completed dimension " <> ToString[dimlist[[i]]] <> " of " <> ToString[dimlist] <> " at " <> ToString[DateString[]]],
   {i, 1, Length[dimlist]}];
  ]
										</code>
									</pre>
									
									<p align="left">Here is an example of it being run. The options are:</p>
										<ul style="margin-left: auto; margin-right: auto; width: 75%;">
											<li>order of size, n, determines pixel dimensions of map at 2^n+1 pixels per side</li>
											<li>lower bound on the range of initial jitter</li>
											<li>upper bound on the range of initial jitter</li>
											<li>lower bound on jitter function</li>
											<li>upper bound on jitter function, jitter is a random real between the lower and upper bounds</li>
											<li>tell the code if you want it to save the file will each iteration, 1 if you do</li>
											<li>path to a file you want to save your sparse array, .cua file recommended, if you choose a .txt, .tab, or .csv it will take a while to write big files.</li>
										</ul>

									<pre><code>
arraymapmaker[8, -1, 1, -100/(i*6)^2, 100/(i*6)^2, 1, "~/map7.cua"]
									</code></pre>
									
									<pre><code>
map = Import["~/Desktop/map7.cua"];
normmap = (map - Min[map])/Max[map - Min[map]];
colorf1 =
If[# < 0.25, ColorData["DarkTerrain"][0.06],
If[# < 0.3, ColorData["DarkTerrain"][0.12],
"DarkTerrain"~Blend~(#)]] &;

ArrayPlot[normmap, Mesh -> None, ImageSize -> Medium, ColorFunction -> colorf1, Frame -> False]

									</code></pre>
									
									 <img src="/images/terrain-generator/map7.jpg" alt="map">
									
									<p align="left">These maps turned out well for what I wanted though the biggest challenge faced was managing the size. A detailed map would require an order, n, of 10 or 11. 10 was manageable but at 2049x2048 pixels order 11 was taking ages on my computer.
									<br>
									I did look into parallelizing the Do loops with ParallelDo[] but it seems the sparse arrays make this impossibleÂ or I couldn't find the right solution.
									<br>
									I was able to come up with a solution that worker for me and reduced the time significantly. My main purpose for this is to make global maps that get wrapped onto a sphere. A standard projection just needs an image with an aspect ratio of roughly 2:1. A limitation of the diamond-square algorithm is that it needs to have sides of 2^n+1 pixels but actually it can be 2^n+1 in one direction and (2^n)/2+1 in the other meaning I can make 2:1 maps with a slight code modification. Essentially all I needed to do was change every instance where the code calls is changing in the north-south direction and asks for the size (2^n+1) I just have to tell it the half size ((2^n)/2+1).
									</p>
									
							</section>

					</div>
				</div>

			<!-- Footer -->
			<div id="footer-template"><!--Your footer.html placeholder--></div>

		</div>

		<!-- Scripts -->
			<script src="/assets/js/jquery.min.js"></script>
			<script src="/assets/js/jquery.scrolly.min.js"></script>
			<script src="/assets/js/jquery.dropotron.min.js"></script>
			<script src="/assets/js/jquery.scrollex.min.js"></script>
			<script src="/assets/js/browser.min.js"></script>
			<script src="/assets/js/breakpoints.min.js"></script>
			<script src="/assets/js/util.js"></script>
			<script src="/assets/js/main.js"></script>
			<!--<script src="https://code.jquery.com/jquery-1.10.2.js"></script>-->
			<script>
			$(function(){
			$("#header-template").load("/header.html");
			$("#footer-template").load("/footer.html");
			});
			</script>

	</body>
</html>
